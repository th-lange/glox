package util

import (
	"bytes"
	"go/format"
	"html/template"
	"io/ioutil"
	"os"
	"strings"
)

type TemplateMap map[string]interface{}

type astDefElement struct {
	Name  string
	TType string
}

type astDef struct {
	Name           string
	ImportRequired bool
	Elements       []astDefElement
}

var astDefinition = []astDef{
	{"Expression", false, []astDefElement{}},
	{"Binary", true, []astDefElement{{"Left", "Expression"}, {"Operator", "scanner.Token"}, {"Right", "Expression"}}},
	{"Grouping", false, []astDefElement{{"Expr", "Expression"}}},
	{"Literal", true, []astDefElement{{"Value", "scanner.Token"}}},
	{"Unary", true, []astDefElement{{"Operator", "scanner.Token"}, {"Right", "Expression"}}},
}

func GenerateAst(homeDir, packageName string) {

	basePath := homeDir + string(os.PathSeparator) + packageName
	if _, err := os.Stat(basePath); os.IsNotExist(err) {
		err := os.Mkdir(basePath, os.ModePerm)
		checkErr(err, "Could not create path: "+basePath+"!\nError:"+err.Error())
	}
	writeToFile(basePath+string(os.PathSeparator)+"Warning.md", generateWarining())

	itemTemplate, err := template.ParseFiles(homeDir + string(os.PathSeparator) + "util" + string(os.PathSeparator) + "astElementTemplate.tmpl")
	checkErr(err, "Could not parse template!")
	expressionTemplate, err := template.ParseFiles(homeDir + string(os.PathSeparator) + "util" + string(os.PathSeparator) + "expressionTemplate.tmpl")
	checkErr(err, "Could not parse template!")
	for _, element := range astDefinition {
		if element.Name == "Expression" {
			writeTemplate(packageName, err, expressionTemplate, basePath, &element, element.Name)
		} else {
			writeTemplate(packageName, err, itemTemplate, basePath, &element, element.Name)
		}
	}
}

func GenerateVisitor(homeDir, packageName, visitorName string) {
	basePath := homeDir + string(os.PathSeparator) + packageName
	if _, err := os.Stat(basePath); os.IsNotExist(err) {
		err := os.Mkdir(basePath, os.ModePerm)
		checkErr(err, "Could not create path: "+basePath+"!\nError:"+err.Error())
	}
	visitorTemplate, err := template.ParseFiles(homeDir + string(os.PathSeparator) + "util" + string(os.PathSeparator) + "visitorTemplate.tmpl")
	writeTemplate(packageName, err, visitorTemplate, basePath, nil, visitorName)

}

func writeTemplate(packageName string, err error, t *template.Template, basePath string, element *astDef, name string) {
	var codeBuffer bytes.Buffer
	err = t.Execute(&codeBuffer, TemplateMap{
		"Self":     element,
		"All":      astDefinition,
		"Package":  packageName,
		"ItemName": name,
	})
	checkErr(err, "Could not generate template!")
	formatedCode, err := format.Source(codeBuffer.Bytes())
	checkErr(err, "Could not format source code!")
	filePointer, err := os.Create(basePath + string(os.PathSeparator) + strings.ToLower(name) + ".go")
	checkErr(err, "Could not open file pointer!")
	_, err = filePointer.Write(formatedCode)
	checkErr(err, "Could not write to file pointer!")
}

func writeToFile(file string, content string) {
	println(file)
	err := ioutil.WriteFile(file, []byte(content), 0644)
	checkErr(err, "Could not write file: "+file+"!\nWith content: \n"+content+"\nCowardly refusing to carry on! Exiting!")
}

func checkErr(err error, msg string) {
	if err != nil {
		panic(msg + "\nError:" + err.Error())
	}
}

func generateWarining() string {
	return `# Warning

This folder is autogenerated.
Do not modify it's content! It might be overwritten!

One can choose a different package name / folder to test and compare, using the "--target" or "-t" option

## These files get overwritten:
- expression/binary.go
- expression/expression.go
- expression/expression.go
- expression/grouping.go
- expression/literal.go
- expression/unary.go
- expression/Warning.md

`
}
